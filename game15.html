<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Galaxy — 3D Simulation (Working Build)</title>
<style>
  html,body { height:100%; margin:0; background:#000; color:#ddd; font-family:Inter,Arial; }
  #uiHint { position:fixed; left:12px; bottom:12px; z-index:20; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px; font-size:13px; }
  .dg { z-index: 30 !important; } /* dat.GUI over canvas */
</style>
</head>
<body>
<div id="uiHint">Left-drag rotate • Scroll zoom • Right-drag pan • Double-click to reset • Settings on top-right</div>

<!-- Core libs from CDN (non-module) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

<script>
/*
  Working Galaxy Simulation (compact, robust)
  - Uses Three.js + OrbitControls + dat.GUI
  - localStorage saves camera & settings
  - Starfield background + spiral galaxy points + glowing core sprite
  - If this runs OK, tell me and I'll produce the larger ultra-realistic version.
*/

let scene, camera, renderer, controls;
let galaxyPoints = null, starfield = null, coreSprite = null;
let gui;
let params = {
  starCount: 60000,         // number of stars in the galaxy (change carefully)
  galaxyRadius: 160,        // radius of the spiral galaxy
  branches: 4,              // spiral arms
  spin: 1.1,                // twist of arms
  randomness: 0.55,         // spread off the arm center
  randomnessPower: 2.2,     // randomness shaping
  thickness: 8,             // vertical thickness
  innerColor: '#ffe7c1',
  outerColor: '#7fb6ff',
  rotationSpeed: 0.0009,    // galaxy self-rotation speed
  saveCamera: true
};

// ---------- init ----------
function init(){
  // scene & camera
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 4000);
  camera.position.set(0, 35, 420);

  // renderer
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 1);
  document.body.appendChild(renderer.domElement);

  // controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.09;
  controls.minDistance = 10;
  controls.maxDistance = 2500;
  controls.zoomSpeed = 1.1;

  // dat.GUI
  gui = new dat.GUI();
  gui.add(params, 'starCount', 5000, 150000, 1000).name('Stars').onFinishChange(rebuildGalaxy);
  gui.add(params, 'galaxyRadius', 50, 600, 1).name('Radius').onFinishChange(rebuildGalaxy);
  gui.add(params, 'branches', 2, 8, 1).name('Arms').onFinishChange(rebuildGalaxy);
  gui.add(params, 'spin', -3, 3, 0.01).name('Spin').onFinishChange(rebuildGalaxy);
  gui.add(params, 'randomness', 0, 1.6, 0.01).name('Spread').onFinishChange(rebuildGalaxy);
  gui.add(params, 'randomnessPower', 0.5, 6, 0.1).name('Rand Power').onFinishChange(rebuildGalaxy);
  gui.add(params, 'thickness', 1, 40, 1).name('Thickness').onFinishChange(rebuildGalaxy);
  gui.addColor(params, 'innerColor').name('Inner Color').onFinishChange(rebuildGalaxy);
  gui.addColor(params, 'outerColor').name('Outer Color').onFinishChange(rebuildGalaxy);
  gui.add(params, 'rotationSpeed', -0.005, 0.01, 0.0001).name('Spin Speed');
  gui.add(params, 'saveCamera').name('Persist Camera');

  // load saved camera if available
  try {
    const saved = localStorage.getItem('galaxy_camera_v1');
    if(saved){
      const s = JSON.parse(saved);
      camera.position.set(s.x, s.y, s.z);
      camera.lookAt(new THREE.Vector3(s.tx, s.ty, s.tz));
    }
  } catch(e){ /* ignore */ }

  // build visuals
  buildStarfield();
  rebuildGalaxy();

  // event listeners
  window.addEventListener('resize', onResize, false);
  renderer.domElement.addEventListener('dblclick', resetView, false);

  // save camera periodically (and on unload)
  setInterval(() => {
    if(params.saveCamera) saveCamera();
  }, 2500);
  window.addEventListener('beforeunload', ()=> saveCamera());
}

// ---------- starfield background ----------
function buildStarfield(){
  if(starfield){
    starfield.geometry.dispose();
    starfield.material.dispose();
    scene.remove(starfield);
    starfield = null;
  }

  const count = 12000;
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const colors = new Float32Array(count * 3);

  for(let i=0;i<count;i++){
    // distribute stars on large sphere shell for depth
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2*Math.random()-1);
    const r = 800 + Math.random()*1200;
    const x = Math.sin(phi) * Math.cos(theta) * r;
    const y = Math.sin(phi) * Math.sin(theta) * r;
    const z = Math.cos(phi) * r;

    positions[i*3] = x;
    positions[i*3+1] = y;
    positions[i*3+2] = z;

    sizes[i] = 0.8 + Math.random()*2.2;

    const c = (Math.random() * 0.6 + 0.4); // subtle brightness
    colors[i*3] = c;
    colors[i*3+1] = c;
    colors[i*3+2] = c;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.PointsMaterial({
    size:1.2,
    vertexColors: true,
    depthWrite: false,
    transparent: true,
    opacity: 0.95,
    blending: THREE.AdditiveBlending
  });

  starfield = new THREE.Points(geo, mat);
  scene.add(starfield);
}

// ---------- galaxy (spiral) ----------
function rebuildGalaxy(){
  // remove old
  if(galaxyPoints){
    galaxyPoints.geometry.dispose();
    galaxyPoints.material.dispose();
    scene.remove(galaxyPoints);
    galaxyPoints = null;
  }
  if(coreSprite){
    scene.remove(coreSprite);
    coreSprite.material.map.dispose();
    coreSprite.material.dispose();
    coreSprite = null;
  }

  const count = Math.max(1000, Math.floor(params.starCount));
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);

  const colInner = new THREE.Color(params.innerColor);
  const colOuter = new THREE.Color(params.outerColor);

  for(let i=0;i<count;i++){
    // radius with bias to make denser core: use power distribution
    const t = Math.random();
    const radius = Math.pow(t, 0.6) * params.galaxyRadius;

    // which arm
    const arm = i % params.branches;
    const armAngle = (arm / params.branches) * Math.PI * 2;

    // spin increases with radius
    const spinAngle = radius * params.spin * 0.12;

    // base angle for this star
    const baseAngle = armAngle + spinAngle;

    // randomness offset
    const randX = (Math.random()**params.randomnessPower) * (Math.random()<0.5?-1:1) * params.randomness * (params.galaxyRadius - radius) * 0.6;
    const randY = (Math.random()**params.randomnessPower) * (Math.random()<0.5?-1:1) * params.randomness * params.thickness * (1 - radius/params.galaxyRadius);
    const randZ = (Math.random()**params.randomnessPower) * (Math.random()<0.5?-1:1) * params.randomness * (params.galaxyRadius - radius) * 0.6;

    const x = Math.cos(baseAngle) * radius + randX;
    const y = randY * 0.5; // slightly thinner
    const z = Math.sin(baseAngle) * radius + randZ;

    positions[i*3] = x;
    positions[i*3+1] = y;
    positions[i*3+2] = z;

    // color mixes from inner to outer, plus slight randomness
    const mix = Math.min(1, radius / params.galaxyRadius);
    const col = colInner.clone().lerp(colOuter, mix);
    // brightness flicker
    const flick = 0.8 + Math.random() * 1.2;
    colors[i*3] = Math.min(1, col.r * flick);
    colors[i*3+1] = Math.min(1, col.g * flick);
    colors[i*3+2] = Math.min(1, col.b * flick);

    sizes[i] = (0.5 + Math.random()*1.8) * (1 - mix*0.85); // smaller toward edges
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

  // custom shader material to use per-point sizes (since PointsMaterial ignores size attribute)
  const vertexShader = `
    attribute float size;
    varying vec3 vColor;
    void main() {
      vColor = color;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * (300.0 / -mvPosition.z); // perspective size attenuation
      gl_Position = projectionMatrix * mvPosition;
    }
  `;
  const fragmentShader = `
    varying vec3 vColor;
    void main() {
      // point shape (soft circle)
      float r = length(gl_PointCoord - vec2(0.5));
      float alpha = smoothstep(0.5, 0.2, r);
      vec3 col = vColor;
      gl_FragColor = vec4(col, alpha);
    }
  `;

  const material = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    transparent: true,
    depthWrite: false,
    vertexColors: true,
    blending: THREE.AdditiveBlending
  });

  galaxyPoints = new THREE.Points(geometry, material);
  scene.add(galaxyPoints);

  // create glowing core sprite
  coreSprite = makeCoreSprite(120, params.innerColor);
  coreSprite.position.set(0, 0, 0);
  scene.add(coreSprite);
}

// ---------- helper: create a radial gradient sprite used as core glow ----------
function makeCoreSprite(size=128, colorHex='#fff'){
  const canvas = document.createElement('canvas');
  const s = 256;
  canvas.width = s; canvas.height = s;
  const ctx = canvas.getContext('2d');

  // radial gradient: center bright -> outer transparent
  const gradient = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
  gradient.addColorStop(0, colorHex);
  gradient.addColorStop(0.12, 'rgba(255, 230, 200, 0.85)');
  gradient.addColorStop(0.25, 'rgba(200,180,255,0.25)');
  gradient.addColorStop(0.7, 'rgba(0,0,0,0.0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0,0,s,s);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false,
    opacity: 0.95
  });

  const sprite = new THREE.Sprite(mat);
  const scale = size * (params.galaxyRadius / 160);
  sprite.scale.set(scale, scale, 1.0);
  return sprite;
}

// ---------- animation loop ----------
function animate(){
  requestAnimationFrame(animate);
  // rotate galaxy slowly
  if(galaxyPoints) galaxyPoints.rotation.y += params.rotationSpeed;
  if(coreSprite) coreSprite.rotation.y += params.rotationSpeed * 0.6;

  controls.update();
  renderer.render(scene, camera);
}
function onResize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ---------- camera saving ----------
function saveCamera(){
  if(!params.saveCamera) return;
  try{
    const target = controls.target || new THREE.Vector3(0,0,0);
    const state = {
      x: camera.position.x, y: camera.position.y, z: camera.position.z,
      tx: target.x, ty: target.y, tz: target.z
    };
    localStorage.setItem('galaxy_camera_v1', JSON.stringify(state));
  }catch(e){}
}
function resetView(){
  // smooth reset
  controls.reset();
  camera.position.set(0,35,420);
  controls.update();
  saveCamera();
}

// ---------- minimal UI/keys ----------
window.addEventListener('keydown', (e)=>{
  if(e.key === 'r') resetView();
});

// ---------- start ----------
init();
animate();

</script>
</body>
</html>
