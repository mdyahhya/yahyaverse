<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Changer Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .studio-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .main-interface {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .voice-selector {
            margin-bottom: 25px;
        }

        .voice-selector h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 1.3rem;
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .voice-option {
            padding: 15px 10px;
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        .voice-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border-color: rgba(255,255,255,0.3);
        }

        .voice-option.active {
            background: linear-gradient(145deg, #4ecdc4, #45b7d1);
            border-color: #fff;
            transform: scale(1.05);
        }

        .voice-option .emoji {
            font-size: 1.8rem;
            display: block;
            margin-bottom: 8px;
        }

        .recording-interface {
            text-align: center;
            position: relative;
        }

        .waveform-container {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            height: 200px;
            position: relative;
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .record-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 15px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .record-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            box-shadow: 0 4px 15px rgba(255,107,107,0.4);
        }

        .record-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,107,107,0.6);
        }

        .record-btn.recording {
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 4px 15px rgba(255,107,107,0.4); }
            50% { box-shadow: 0 8px 30px rgba(255,107,107,0.8); }
        }

        .play-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .stop-btn {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .download-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .effects-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .effect-control {
            margin-bottom: 20px;
        }

        .effect-control label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4ecdc4;
        }

        .slider-container {
            position: relative;
            margin-bottom: 10px;
        }

        .effect-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .effect-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .effect-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: -25px;
            background: rgba(0,0,0,0.7);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .visualizer-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .frequency-analyzer, .spectrum-analyzer {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 15px;
            height: 200px;
        }

        .analyzer-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .status-display {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-text {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .recording-timer {
            font-size: 2rem;
            font-weight: bold;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
        }

        .preset-voices {
            margin-bottom: 20px;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
        }

        .preset-btn {
            padding: 12px 8px;
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            text-align: center;
        }

        .preset-btn:hover {
            background: linear-gradient(145deg, #4ecdc4, #45b7d1);
            transform: translateY(-1px);
        }

        .preset-btn.active {
            background: linear-gradient(145deg, #ff6b6b, #ee5a52);
        }

        .audio-info {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 10px;
            font-size: 0.8rem;
            margin-top: 15px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .particle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .floating-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #4ecdc4, #45b7d1);
            border-radius: 50%;
            opacity: 0.6;
            animation: float-particle 15s infinite linear;
        }

        @keyframes float-particle {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-10px) rotate(360deg);
                opacity: 0;
            }
        }

        .error-message {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin: 20px 0;
            display: none;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @media (max-width: 768px) {
            .main-interface {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .voice-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .record-controls {
                gap: 10px;
            }
            
            .control-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="particle-bg" id="particleBg"></div>
    
    <div class="studio-container">
        <div class="header">
            <h1>🎤 AI Voice Changer Studio</h1>
            <div class="subtitle">Transform your voice with advanced audio processing</div>
        </div>

        <div class="error-message" id="errorMessage"></div>

        <div class="status-display">
            <div class="status-text" id="statusText">Click "Start Recording" to begin</div>
            <div class="recording-timer" id="recordingTimer">00:00</div>
        </div>

        <div class="main-interface">
            <!-- Voice Selection Panel -->
            <div class="control-panel">
                <div class="voice-selector">
                    <h3>🎭 Voice Characters</h3>
                    <div class="voice-grid">
                        <div class="voice-option active" data-voice="normal">
                            <span class="emoji">😊</span>
                            Normal
                        </div>
                        <div class="voice-option" data-voice="girl">
                            <span class="emoji">👧</span>
                            Girl
                        </div>
                        <div class="voice-option" data-voice="woman">
                            <span class="emoji">👩</span>
                            Woman
                        </div>
                        <div class="voice-option" data-voice="child">
                            <span class="emoji">🧒</span>
                            Child
                        </div>
                        <div class="voice-option" data-voice="elderly">
                            <span class="emoji">👴</span>
                            Elderly
                        </div>
                        <div class="voice-option" data-voice="robot">
                            <span class="emoji">🤖</span>
                            Robot
                        </div>
                    </div>
                </div>

                <div class="voice-selector">
                    <h3>🐾 Animal Voices</h3>
                    <div class="voice-grid">
                        <div class="voice-option" data-voice="cat">
                            <span class="emoji">🐱</span>
                            Cat
                        </div>
                        <div class="voice-option" data-voice="dog">
                            <span class="emoji">🐶</span>
                            Dog
                        </div>
                        <div class="voice-option" data-voice="bird">
                            <span class="emoji">🐦</span>
                            Bird
                        </div>
                        <div class="voice-option" data-voice="monster">
                            <span class="emoji">👹</span>
                            Monster
                        </div>
                        <div class="voice-option" data-voice="alien">
                            <span class="emoji">👽</span>
                            Alien
                        </div>
                        <div class="voice-option" data-voice="demon">
                            <span class="emoji">😈</span>
                            Demon
                        </div>
                    </div>
                </div>

                <div class="preset-voices">
                    <h3>🎵 Quick Presets</h3>
                    <div class="preset-grid">
                        <button class="preset-btn" data-preset="helium">Helium</button>
                        <button class="preset-btn" data-preset="deep">Deep Bass</button>
                        <button class="preset-btn" data-preset="chipmunk">Chipmunk</button>
                        <button class="preset-btn" data-preset="echo">Echo</button>
                        <button class="preset-btn" data-preset="reverb">Cathedral</button>
                        <button class="preset-btn" data-preset="distortion">Distorted</button>
                    </div>
                </div>
            </div>

            <!-- Recording Interface -->
            <div class="control-panel">
                <div class="waveform-container">
                    <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                </div>

                <div class="record-controls">
                    <button class="control-btn record-btn" id="recordBtn">
                        <span>🎙️</span> Start Recording
                    </button>
                    <button class="control-btn stop-btn" id="stopBtn">
                        <span>⏹️</span> Stop
                    </button>
                    <button class="control-btn play-btn" id="playBtn">
                        <span>▶️</span> Play
                    </button>
                    <button class="control-btn download-btn" id="downloadBtn">
                        <span>💾</span> Download
                    </button>
                </div>

                <div class="audio-info" id="audioInfo">
                    <div class="info-row">
                        <span>Duration:</span>
                        <span id="audioDuration">0.0s</span>
                    </div>
                    <div class="info-row">
                        <span>Sample Rate:</span>
                        <span id="sampleRate">44.1kHz</span>
                    </div>
                    <div class="info-row">
                        <span>Format:</span>
                        <span>WAV / 16-bit</span>
                    </div>
                    <div class="info-row">
                        <span>Voice Mode:</span>
                        <span id="currentVoiceMode">Normal</span>
                    </div>
                </div>
            </div>

            <!-- Effects Panel -->
            <div class="control-panel effects-panel">
                <h3>🎛️ Audio Effects</h3>
                
                <div class="effect-control">
                    <label>Pitch Shift</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="pitchSlider" min="-12" max="12" value="0" step="0.1">
                        <span class="slider-value" id="pitchValue">0</span>
                    </div>
                </div>

                <div class="effect-control">
                    <label>Speed / Tempo</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="speedSlider" min="0.5" max="2.0" value="1.0" step="0.05">
                        <span class="slider-value" id="speedValue">1.0x</span>
                    </div>
                </div>

                <div class="effect-control">
                    <label>Reverb</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="reverbSlider" min="0" max="100" value="0">
                        <span class="slider-value" id="reverbValue">0</span>
                    </div>
                </div>

                <div class="effect-control">
                    <label>Echo</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="echoSlider" min="0" max="100" value="0">
                        <span class="slider-value" id="echoValue">0</span>
                    </div>
                </div>

                <div class="effect-control">
                    <label>Distortion</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="distortionSlider" min="0" max="100" value="0">
                        <span class="slider-value" id="distortionValue">0</span>
                    </div>
                </div>

                <div class="effect-control">
                    <label>Low Pass Filter</label>
                    <div class="slider-container">
                        <input type="range" class="effect-slider" id="filterSlider" min="200" max="20000" value="20000">
                        <span class="slider-value" id="filterValue">20kHz</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="visualizer-container">
            <div class="frequency-analyzer">
                <h4>🌊 Frequency Analyzer</h4>
                <canvas class="analyzer-canvas" id="frequencyCanvas"></canvas>
            </div>
            <div class="spectrum-analyzer">
                <h4>📊 Spectrum Analyzer</h4>
                <canvas class="analyzer-canvas" id="spectrumCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        class VoiceChangerStudio {
            constructor() {
                // Audio Context and Nodes
                this.audioContext = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.stream = null;
                this.sourceNode = null;
                this.destinationNode = null;
                
                // Audio Effects Nodes
                this.pitchShifter = null;
                this.reverb = null;
                this.delay = null;
                this.distortion = null;
                this.filter = null;
                this.analyser = null;
                this.gainNode = null;
                
                // Tone.js Components
                this.toneReady = false;
                this.player = null;
                this.effects = {};
                
                // Recording State
                this.isRecording = false;
                this.isPlaying = false;
                this.recordedAudioBuffer = null;
                this.recordingStartTime = 0;
                this.recordingTimer = null;
                
                // Voice Settings
                this.currentVoice = 'normal';
                this.voiceSettings = {
                    normal: { pitch: 0, speed: 1.0, formant: 1.0 },
                    girl: { pitch: 4, speed: 1.1, formant: 1.3 },
                    woman: { pitch: 2, speed: 0.95, formant: 1.1 },
                    child: { pitch: 6, speed: 1.2, formant: 1.4 },
                    elderly: { pitch: -3, speed: 0.8, formant: 0.8 },
                    robot: { pitch: -1, speed: 0.9, formant: 0.7 },
                    cat: { pitch: 8, speed: 1.3, formant: 1.5 },
                    dog: { pitch: -4, speed: 0.7, formant: 0.6 },
                    bird: { pitch: 10, speed: 1.5, formant: 1.8 },
                    monster: { pitch: -8, speed: 0.6, formant: 0.4 },
                    alien: { pitch: 3, speed: 1.1, formant: 1.6 },
                    demon: { pitch: -10, speed: 0.5, formant: 0.3 }
                };
                
                // Visualization
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.waveformCtx = this.waveformCanvas.getContext('2d');
                this.frequencyCanvas = document.getElementById('frequencyCanvas');
                this.frequencyCtx = this.frequencyCanvas.getContext('2d');
                this.spectrumCanvas = document.getElementById('spectrumCanvas');
                this.spectrumCtx = this.spectrumCanvas.getContext('2d');
                
                this.initializeAudio();
                this.setupEventListeners();
                this.createParticleBackground();
                this.setupCanvases();
            }

            async initializeAudio() {
                try {
                    // Initialize Tone.js
                    await Tone.start();
                    this.toneReady = true;
                    
                    // Create Web Audio Context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Setup Tone.js effects
                    this.setupToneEffects();
                    
                    this.updateStatus('Audio system initialized - Ready to record!');
                } catch (error) {
                    this.showError('Failed to initialize audio system: ' + error.message);
                }
            }

            setupToneEffects() {
                // Create Tone.js effect chain
                this.effects = {
                    pitchShift: new Tone.PitchShift(0).toDestination(),
                    reverb: new Tone.Reverb(2).toDestination(),
                    delay: new Tone.FeedbackDelay("8n", 0.2).toDestination(),
                    distortion: new Tone.Distortion(0).toDestination(),
                    filter: new Tone.Filter(20000, "lowpass").toDestination(),
                    chorus: new Tone.Chorus(4, 2.5, 0.5).toDestination(),
                    phaser: new Tone.Phaser({
                        frequency: 0.5,
                        octaves: 3,
                        stages: 10,
                        Q: 10,
                        baseFrequency: 350
                    }).toDestination(),
                    autoWah: new Tone.AutoWah(50, 6, -30).toDestination()
                };

                // Chain effects
                this.effects.pitchShift.connect(this.effects.reverb);
                this.effects.reverb.connect(this.effects.delay);
                this.effects.delay.connect(this.effects.distortion);
                this.effects.distortion.connect(this.effects.filter);
                this.effects.filter.connect(this.effects.chorus);
                this.effects.chorus.connect(this.effects.phaser);
                this.effects.phaser.connect(this.effects.autoWah);
            }

            setupEventListeners() {
                // Recording controls
                document.getElementById('recordBtn').addEventListener('click', () => this.toggleRecording());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('playBtn').addEventListener('click', () => this.playRecording());
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadRecording());

                // Voice selection
                document.querySelectorAll('.voice-option').forEach(option => {
                    option.addEventListener('click', (e) => this.selectVoice(e.currentTarget.dataset.voice));
                });

                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.applyPreset(e.currentTarget.dataset.preset));
                });

                // Effect sliders
                this.setupSliderListeners();
            }

            setupSliderListeners() {
                const sliders = [
                    { id: 'pitchSlider', valueId: 'pitchValue', effect: 'pitch' },
                    { id: 'speedSlider', valueId: 'speedValue', effect: 'speed' },
                    { id: 'reverbSlider', valueId: 'reverbValue', effect: 'reverb' },
                    { id: 'echoSlider', valueId: 'echoValue', effect: 'echo' },
                    { id: 'distortionSlider', valueId: 'distortionValue', effect: 'distortion' },
                    { id: 'filterSlider', valueId: 'filterValue', effect: 'filter' }
                ];

                sliders.forEach(slider => {
                    const element = document.getElementById(slider.id);
                    const valueElement = document.getElementById(slider.valueId);
                    
                    element.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.updateEffect(slider.effect, value);
                        this.updateSliderValue(slider.valueId, value, slider.effect);
                    });
                });
            }

            updateSliderValue(valueId, value, effect) {
                const element = document.getElementById(valueId);
                switch(effect) {
                    case 'speed':
                        element.textContent = value + 'x';
                        break;
                    case 'filter':
                        element.textContent = value >= 1000 ? (value/1000).toFixed(1) + 'kHz' : value + 'Hz';
                        break;
                    default:
                        element.textContent = value;
                }
            }

            updateEffect(effect, value) {
                if (!this.toneReady) return;

                try {
                    switch(effect) {
                        case 'pitch':
                            this.effects.pitchShift.pitch = value;
                            break;
                        case 'reverb':
                            this.effects.reverb.wet.value = value / 100;
                            break;
                        case 'echo':
                            this.effects.delay.wet.value = value / 100;
                            break;
                        case 'distortion':
                            this.effects.distortion.wet.value = value / 100;
                            this.effects.distortion.distortion = value / 10;
                            break;
                        case 'filter':
                            this.effects.filter.frequency.value = value;
                            break;
                    }
                } catch (error) {
                    console.error('Error updating effect:', error);
                }
            }

            selectVoice(voiceType) {
                this.currentVoice = voiceType;
                
                // Update UI
                document.querySelectorAll('.voice-option').forEach(option => {
                    option.classList.remove('active');
                });
                document.querySelector(`[data-voice="${voiceType}"]`).classList.add('active');
                
                // Apply voice settings
                const settings = this.voiceSettings[voiceType];
                if (settings && this.toneReady) {
                    this.effects.pitchShift.pitch = settings.pitch;
                    document.getElementById('pitchSlider').value = settings.pitch;
                    document.getElementById('pitchValue').textContent = settings.pitch;
                    
                    // Update speed if available
                    if (this.player) {
                        this.player.playbackRate = settings.speed;
                    }
                    document.getElementById('speedSlider').value = settings.speed;
                    document.getElementById('speedValue').textContent = settings.speed + 'x';
                }
                
                // Update UI display
                document.getElementById('currentVoiceMode').textContent = voiceType.charAt(0).toUpperCase() + voiceType.slice(1);
                this.updateStatus(`Voice changed to: ${voiceType.toUpperCase()}`);
            }

            applyPreset(presetType) {
                // Remove active class from all presets
                document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-preset="${presetType}"]`).classList.add('active');
                
                const presets = {
                    helium: { pitch: 8, reverb: 10, speed: 1.2 },
                    deep: { pitch: -6, reverb: 30, speed: 0.8 },
                    chipmunk: { pitch: 10, reverb: 5, speed: 1.5 },
                    echo: { pitch: 0, reverb: 20, echo: 60 },
                    reverb: { pitch: 0, reverb: 80, echo: 20 },
                    distortion: { pitch: -2, distortion: 70, reverb: 10 }
                };
                
                const preset = presets[presetType];
                if (preset) {
                    Object.keys(preset).forEach(effect => {
                        const value = preset[effect];
                        this.updateEffect(effect, value);
                        
                        // Update sliders
                        const sliderId = effect + 'Slider';
                        const valueId = effect + 'Value';
                        if (document.getElementById(sliderId)) {
                            document.getElementById(sliderId).value = value;
                            this.updateSliderValue(valueId, value, effect);
                        }
                    });
                }
                
                this.updateStatus(`Applied preset: ${presetType.toUpperCase()}`);
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    // Request microphone access
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        }
                    });

                    // Setup MediaRecorder
                    this.mediaRecorder = new MediaRecorder(this.stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };

                    // Setup real-time audio analysis
                    this.setupRealTimeAnalysis();

                    // Start recording
                    this.mediaRecorder.start(100);
                    this.isRecording = true;
                    this.recordingStartTime = Date.now();
                    
                    // Update UI
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '<span>⏸️</span> Recording...';
                    
                    this.updateStatus('Recording in progress...');
                    this.startRecordingTimer();
                    this.startWaveformVisualization();

                } catch (error) {
                    this.showError('Failed to start recording: ' + error.message);
                }
            }

            setupRealTimeAnalysis() {
                // Create audio analysis chain
                this.sourceNode = this.audioContext.createMediaStreamSource(this.stream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                this.sourceNode.connect(this.analyser);
                
                // Update sample rate display
                document.getElementById('sampleRate').textContent = (this.audioContext.sampleRate / 1000).toFixed(1) + 'kHz';
            }

            startRecordingTimer() {
                this.recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const seconds = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('recordingTimer').textContent = `${minutes}:${seconds}`;
                }, 1000);
            }

            stopRecording() {
                if (!this.isRecording) return;

                this.mediaRecorder.stop();
                this.stream.getTracks().forEach(track => track.stop());
                this.isRecording = false;
                
                // Update UI
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = '<span>🎙️</span> Start Recording';
                
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                }
                
                this.updateStatus('Recording stopped - Processing audio...');
                this.stopWaveformVisualization();
            }

            async processRecording() {
                try {
                    // Create blob from recorded chunks
                    const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                    
                    // Convert to AudioBuffer for processing
                    const arrayBuffer = await blob.arrayBuffer();
                    this.recordedAudioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    // Update duration display
                    const duration = this.recordedAudioBuffer.duration.toFixed(1);
                    document.getElementById('audioDuration').textContent = duration + 's';
                    
                    this.updateStatus('Recording ready - Click Play to hear with effects!');
                    
                } catch (error) {
                    this.showError('Failed to process recording: ' + error.message);
                }
            }

            async playRecording() {
                if (!this.recordedAudioBuffer || this.isPlaying) return;

                try {
                    this.isPlaying = true;
                    
                    // Create a new Tone.js player from the recorded buffer
                    if (this.player) {
                        this.player.dispose();
                    }
                    
                    // Convert AudioBuffer to Tone.js compatible format
                    const toneBuffer = new Tone.ToneAudioBuffer();
                    toneBuffer.set(this.recordedAudioBuffer);
                    
                    this.player = new Tone.Player(toneBuffer);
                    
                    // Apply current voice settings
                    const voiceSettings = this.voiceSettings[this.currentVoice];
                    this.player.playbackRate = voiceSettings.speed;
                    
                    // Connect through effects chain
                    this.player.connect(this.effects.pitchShift);
                    
                    // Update UI
                    const playBtn = document.getElementById('playBtn');
                    playBtn.innerHTML = '<span>⏸️</span> Playing...';
                    
                    // Play with callback
                    this.player.start();
                    
                    this.updateStatus('Playing with voice effects...');
                    
                    // Reset UI when playback ends
                    setTimeout(() => {
                        this.isPlaying = false;
                        playBtn.innerHTML = '<span>▶️</span> Play';
                        this.updateStatus('Playback complete');
                    }, this.recordedAudioBuffer.duration * 1000 * voiceSettings.speed);
                    
                } catch (error) {
                    this.showError('Failed to play recording: ' + error.message);
                    this.isPlaying = false;
                }
            }

            downloadRecording() {
                if (!this.recordedChunks.length) {
                    this.showError('No recording to download');
                    return;
                }

                try {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `voice_changed_${this.currentVoice}_${Date.now()}.webm`;
                    a.click();
                    
                    URL.revokeObjectURL(url);
                    this.updateStatus('Recording downloaded!');
                    
                } catch (error) {
                    this.showError('Failed to download recording: ' + error.message);
                }
            }

            startWaveformVisualization() {
                if (!this.analyser) return;

                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const freqDataArray = new Uint8Array(this.analyser.frequencyBinCount);
                
                const draw = () => {
                    if (!this.isRecording) return;
                    
                    requestAnimationFrame(draw);
                    
                    // Get waveform data
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.analyser.getByteFrequencyData(freqDataArray);
                    
                    this.drawWaveform(dataArray);
                    this.drawFrequencyAnalyzer(freqDataArray);
                    this.drawSpectrumAnalyzer(freqDataArray);
                };
                
                draw();
            }

            drawWaveform(dataArray) {
                const canvas = this.waveformCanvas;
                const ctx = this.waveformCtx;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#4ecdc4';
                ctx.beginPath();
                
                const sliceWidth = canvas.width / dataArray.length;
                let x = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                
                // Add glow effect
                ctx.shadowColor = '#4ecdc4';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            drawFrequencyAnalyzer(dataArray) {
                const canvas = this.frequencyCanvas;
                const ctx = this.frequencyCtx;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / dataArray.length * 2.5;
                let x = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    // Create gradient
                    const gradient = ctx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(0.5, '#4ecdc4');
                    gradient.addColorStop(1, '#45b7d1');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }

            drawSpectrumAnalyzer(dataArray) {
                const canvas = this.spectrumCanvas;
                const ctx = this.spectrumCtx;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#ff6b6b';
                ctx.beginPath();
                
                const sliceWidth = canvas.width / dataArray.length;
                let x = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 255.0;
                    const y = (1 - v) * canvas.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
            }

            stopWaveformVisualization() {
                // Clear canvases
                this.waveformCtx.clearRect(0, 0, this.waveformCanvas.width, this.waveformCanvas.height);
                this.frequencyCtx.clearRect(0, 0, this.frequencyCanvas.width, this.frequencyCanvas.height);
                this.spectrumCtx.clearRect(0, 0, this.spectrumCanvas.width, this.spectrumCanvas.height);
            }

            setupCanvases() {
                // Setup responsive canvas sizing
                const resizeCanvases = () => {
                    [this.waveformCanvas, this.frequencyCanvas, this.spectrumCanvas].forEach(canvas => {
                        canvas.width = canvas.offsetWidth;
                        canvas.height = canvas.offsetHeight;
                    });
                };
                
                window.addEventListener('resize', resizeCanvases);
                resizeCanvases();
            }

            createParticleBackground() {
                const particleBg = document.getElementById('particleBg');
                
                const createParticle = () => {
                    const particle = document.createElement('div');
                    particle.className = 'floating-particle';
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                    particle.style.animationDelay = Math.random() * 5 + 's';
                    
                    particleBg.appendChild(particle);
                    
                    setTimeout(() => {
                        particle.remove();
                    }, 20000);
                };
                
                // Create particles periodically
                setInterval(createParticle, 2000);
                
                // Initial particles
                for (let i = 0; i < 10; i++) {
                    setTimeout(createParticle, i * 500);
                }
            }

            updateStatus(message) {
                document.getElementById('statusText').textContent = message;
                
                // Animate status update
                gsap.fromTo('#statusText', 
                    { opacity: 0, y: -10 },
                    { opacity: 1, y: 0, duration: 0.3 }
                );
            }

            showError(message) {
                const errorEl = document.getElementById('errorMessage');
                errorEl.textContent = message;
                errorEl.style.display = 'block';
                
                gsap.fromTo(errorEl, 
                    { opacity: 0, y: -20 },
                    { opacity: 1, y: 0, duration: 0.3 }
                );
                
                setTimeout(() => {
                    gsap.to(errorEl, {
                        opacity: 0,
                        y: -20,
                        duration: 0.3,
                        onComplete: () => {
                            errorEl.style.display = 'none';
                        }
                    });
                }, 5000);
            }
        }

        // Initialize the voice changer when page loads
        window.addEventListener('load', () => {
            new VoiceChangerStudio();
        });

        // Handle page visibility for audio context
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden && window.voiceChanger && window.voiceChanger.audioContext) {
                if (window.voiceChanger.audioContext.state === 'suspended') {
                    await window.voiceChanger.audioContext.resume();
                }
            }
        });
    </script>
</body>
</html>
